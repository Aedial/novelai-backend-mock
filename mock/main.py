# generated by fastapi-codegen:
#   filename:  schema.json
#   timestamp: 2022-11-24T02:18:11+00:00
import io
import asyncio
import pathlib
import random
import time
import hashlib
import base64
from random import randrange, choices, random
from string import ascii_lowercase
from typing import Any, List, Union, Dict, Iterable, Optional
from uuid import uuid4

import uvicorn
from fastapi import Depends, FastAPI, Request, status
from fastapi.exceptions import RequestValidationError, HTTPException
from fastapi.responses import ORJSONResponse
from fastapi_jwt_auth import AuthJWT
from fastapi_jwt_auth.exceptions import AuthJWTException
from pydantic import BaseModel
from PIL import Image
from PIL.PngImagePlugin import PngInfo

from .models import (
    AccountInformationResponse,
    AiGenerateImageRequest,
    AiGenerateImageResponse,
    AiGenerateRequest,
    AiGenerateResponse,
    AiGenerateStreamableResponse,
    AiModuleDto,
    AiModuleTrainRequest,
    AiRequestImageGenerationTag,
    AiRequestImageGenerationTagsResponse,
    AiSequenceClassificationResponse,
    ApiError,
    BindSubscriptionRequest,
    BuyTrainingStepsRequest,
    ChangeAccessKeyRequest,
    ChangeSubscriptionPlanRequest,
    CreateUserRequest,
    DeletionFinishRequest,
    DeletionStartRequest,
    EmailVerificationRequest,
    EmailVerificationStartRequest,
    GetKeystoreResponse,
    GiftKeysResponse,
    LoginRequest,
    ObjectsResponse,
    PriorityResponse,
    RecoveryFinishRequest,
    RecoveryStartRequest,
    Status,
    SubscriptionResponse,
    SuccessfulLoginResponse,
    UpdateKeystoreRequest,
    UserAccountDataResponse,
    UserData,
    UserDataInput,
    UserSubmissionInput,
    UserSubmissionVoteInput,
    Model1,
)
from .models import Tokenizer, model_to_tokenizer

from .exceptions import HTTP400Error, HTTP401Error, HTTP404Error, HTTP409Error, JSON409Error
from .db import get_session, get_first_of, get_multiple_of, count, \
    insert_item, update_item, delete_item, \
    verify_exist_with, get_user_id, get_user, \
    SubscriptionTier, User, ObjectType, GiftKey, AiModule, UserSubmission, UserSubmissionVote, \
    AccountVerification, AccountRecovery, AccountDeletion
from .TrainingQueue import TrainingQueue
from .FileSystemHandler import FSHandler
from .UserHandler import UserHandler

app = FastAPI(
    title="NovelAI Backend Mock",
    description="",
    version="0.1",
    contact={},
)


# AuthJWT handling
class AuthJWTSettings(BaseModel):
    authjwt_secret_key: str = "secret"
    # Enable csrf double submit protection. default is True
    authjwt_cookie_csrf_protect: bool = True
    # Change to 'lax' in production to make your website more secure from CSRF Attacks, default is None
    # authjwt_cookie_samesite: str = 'lax'
    # Set access token expiration time to 30 days
    authjwt_access_token_expires = 30 * 24 * 60 * 60


@AuthJWT.load_config
def get_config():
    return AuthJWTSettings()


# Exception handling
@app.exception_handler(AuthJWTException)
def authjwt_exception_handler(_: Request, _exc: AuthJWTException):
    err = HTTP401Error()

    return ORJSONResponse(
        status_code = err.status_code,
        content = ApiError(statusCode = err.status_code, message = err.detail)
        # message = exc.message
    )


@app.exception_handler(HTTPException)
def exception_handler(_: Request, exc: HTTPException):
    return ORJSONResponse(
        status_code = exc.status_code,
        content = ApiError(statusCode = exc.status_code, message = exc.detail)
    )


@app.exception_handler(RequestValidationError)
def exception_handler(_: Request, _exc: RequestValidationError):
    return ORJSONResponse(
        status_code = status.HTTP_400_BAD_REQUEST,
        content = ApiError(statusCode = status.HTTP_400_BAD_REQUEST, message = "A validation error occured.")
    )


# Grab the tokens for text generation (Lorem Ipsum)
def tokens_to_b64(tokens: Iterable[int]) -> str:
    return base64.b64encode(b"".join(t.to_bytes(2, "little") for t in tokens)).decode()


curdir = pathlib.Path(__file__).parent
text_tokens: Dict[Tokenizer, str] = {}
for tokenizer in Tokenizer:
    with open(curdir / f"tokens_{tokenizer.value}.txt") as f:
        text_tokens[tokenizer] = tokens_to_b64(int(e) for e in f.read().split(","))


# Endpoints
@app.get(
    "/",
    status_code=200,
    response_description="Everything is running fine.",
    tags=["/"],
    operation_id="AppController_healthCheck",
)
def app_controller_health_check() -> Any:
    return "OK"


def login_handler(auth: AuthJWT, user: Union[None, User]) -> SuccessfulLoginResponse:
    if user is None:
        raise HTTP401Error("Access Key is incorrect.")

    user_id = user.id
    user_claims = {}

    access_token = auth.create_access_token(user_id, user_claims = user_claims)

    return SuccessfulLoginResponse(accessToken = access_token)


def hash_email(email: str) -> str:
    return hashlib.sha256(email).hexdigest()


@app.post(
    "/user/register",
    response_model=SuccessfulLoginResponse,
    status_code=201,
    response_description="The user has been successfully created.",
    tags=["/user/"],
    responses={
        "400": {"model": ApiError, "description": "A validation error occured."},
        "409": {"model": ApiError, "description": "A conflict error occured."},
        "500": {"model": ApiError, "description": "An unknown error occured."},
    },
    operation_id="UserController_createUser",
)
def user_controller_create_user(
    body: CreateUserRequest, auth: AuthJWT = Depends(), session = Depends(get_session)
) -> SuccessfulLoginResponse:
    user_dict = body.dict()
    if user_dict.get("email") is None and user_dict.get("emailCleartext") is not None:
        user_dict["email"] = hash_email(user_dict["emailCleartext"])

    user = User(**body.dict(exclude_none = True))
    user = insert_item(session, user)

    # TODO: apply gift key if any

    return login_handler(auth, user)


@app.post(
    "/user/login",
    response_model=SuccessfulLoginResponse,
    status_code=201,
    response_description="Login successful.",
    tags=["/user/"],
    responses={
        "400": {"model": ApiError, "description": "A validation error occured."},
        "401": {"model": ApiError, "description": "Access Key is incorrect."},
        "500": {"model": ApiError, "description": "An unknown error occured."},
    },
    operation_id="UserController_loginUser",
)
def user_controller_login_user(
    body: LoginRequest, auth: AuthJWT = Depends(), session = Depends(get_session)
) -> SuccessfulLoginResponse:
    user = get_first_of(session, User, User.access_key == body.key)

    return login_handler(auth, user)


@app.post(
    "/user/change-access-key",
    response_model=SuccessfulLoginResponse,
    status_code=200,
    response_description="Access Key change successful.",
    tags=["/user/"],
    responses={
        "400": {"model": ApiError, "description": "A validation error occured."},
        "401": {"model": ApiError, "description": "Access Token is incorrect."},
        "409": {"model": ApiError, "description": "A conflict error occured."},
        "500": {"model": ApiError, "description": "An unknown error occured."},
    },
    operation_id="UserController_changeAccessKey",
)
def user_controller_change_access_key(
    body: ChangeAccessKeyRequest, auth: AuthJWT = Depends(), session = Depends(get_session)
) -> SuccessfulLoginResponse:
    user = update_item(
        session,
        User,
        User.access_key == body.currentAccessKey,
        access_key = body.newAccessKey,
        email = hash_email(body.newEmail)
    )

    return login_handler(auth, user)


@app.post(
    "/user/resend-email-verification",
    status_code=201,
    response_description="Email verification letter has been sent.",
    tags=["/user/"],
    responses={
        "400": {"model": ApiError, "description": "A validation error occured."},
        "401": {"model": ApiError, "description": "Access Token is incorrect."},
        "409": {"model": ApiError, "description": "A conflict error occured."},
        "500": {"model": ApiError, "description": "An unknown error occured."},
    },
    operation_id="UserController_requestEmailVerification",
)
def user_controller_request_email_verification(
    body: EmailVerificationStartRequest, session = Depends(get_session)
) -> None:
    email = hash_email(body.email)
    user = get_first_of(session, User,)
    if user.email != email:
        raise HTTP409Error()

    # ideally, you want the token to be random
    token = email
    verification = AccountVerification(user_id = user.id, token = token)
    insert_item(session, verification)
    update_item(session, User, User.id == user.id, emailVerificationLetterSent = True)
    # there, an email should be sent and yadi yada


@app.post(
    "/user/verify-email",
    status_code=200,
    response_description="The email has been successfully verified.",
    tags=["/user/"],
    responses={
        "400": {"model": ApiError, "description": "A validation error occured."},
        "401": {"model": ApiError, "description": "Verification token was not found."},
        "500": {"model": ApiError, "description": "An unknown error occured."},
    },
    operation_id="UserController_verifyEmail",
)
def user_controller_verify_email(
    body: EmailVerificationRequest, session = Depends(get_session)
) -> None:
    verification = get_first_of(session, AccountVerification, AccountVerification.token == body.verificationToken)
    if verification is None:
        raise HTTP401Error("Verification token was not found.")

    update_item(session, User, User.id == verification.user_id, emailVerified = True)
    delete_item(session, AccountVerification, AccountVerification.token == verification.token)


@app.get(
    "/user/information",
    response_model=AccountInformationResponse,
    status_code=200,
    response_description="Account information",
    tags=["/user/"],
    responses={
        "401": {"model": ApiError, "description": "Access Token is incorrect."},
        "500": {"model": ApiError, "description": "An unknown error occured."},
    },
    operation_id="UserController_getAccountInformation",
)
def user_controller_get_account_information(
    auth: AuthJWT = Depends(), session = Depends(get_session)
) -> AccountInformationResponse:
    return UserHandler(auth, session).account_information


@app.post(
    "/user/deletion/request",
    status_code=202,
    response_description="Your request has been processed. If the email address provided is registered, "
                         "it will receive a letter with further instructions.",
    tags=["/user/"],
    responses={
        "400": {"model": ApiError, "description": "A validation error occured."},
        "409": {
            "model": ApiError,
            "description": "Cannot delete accounts with active recurring subscriptions.",
        },
        "500": {"model": ApiError, "description": "An unknown error occured."},
    },
    operation_id="UserController_requestAccountDeletion",
)
def user_controller_request_account_deletion(
    body: DeletionStartRequest, auth: AuthJWT = Depends(), session = Depends(get_session)
) -> None:
    user = get_user(auth, session)
    if user.active:
        raise HTTP409Error("Cannot delete accounts with active recurring subscriptions.")

    # ideally, you want the token to be random
    email = hash_email(body.email)
    token = email
    deletion = AccountDeletion(user_id = user.id, token = token)
    insert_item(session, deletion)
    # there, an email should be sent and yadi yada


@app.post(
    "/user/deletion/delete",
    status_code=200,
    response_description="Account deletion successful.",
    tags=["/user/"],
    responses={
        "401": {"model": ApiError, "description": "Deletion token was not found."},
        "409": {
            "model": ApiError,
            "description": "Cannot delete accounts with active recurring subscriptions.",
        },
        "500": {"model": ApiError, "description": "An unknown error occured."},
    },
    operation_id="UserController_deleteAccount",
)
def user_controller_delete_account(
    body: DeletionFinishRequest, session = Depends(get_session)
) -> None:
    deletion = get_first_of(session, AccountDeletion, AccountDeletion.token == body.deletionToken)
    if deletion is None:
        raise HTTP401Error("Deletion token was not found.")

    delete_item(session, User, User.id == deletion.user_id)
    delete_item(session, AccountDeletion, AccountDeletion.token == deletion.token)


@app.post(
    "/user/recovery/request",
    status_code=202,
    response_description="Your request has been processed. If the email address provided is registered, "
                         "it will receive a letter with further instructions.",
    tags=["/user/"],
    responses={
        "400": {"model": ApiError, "description": "A validation error occured."},
        "500": {"model": ApiError, "description": "An unknown error occured."},
    },
    operation_id="UserController_requestAccountRecovery",
)
def user_controller_request_account_recovery(
    body: RecoveryStartRequest, session = Depends(get_session)
) -> None:
    email = hash_email(body.email)
    user = get_first_of(session, User, User.email == email)
    if user is None:
        return

    # ideally, you want the token to be random
    token = email
    recovery = AccountRecovery(token = token, user_id = user.id)

    insert_item(session, recovery)
    # there, an email should be sent and yadi yada


@app.post(
    "/user/recovery/recover",
    response_model=SuccessfulLoginResponse,
    status_code=201,
    response_description="Account recovery successful.",
    tags=["/user/"],
    responses={
        "400": {"model": ApiError, "description": "A validation error occured."},
        "401": {"model": ApiError, "description": "Recovery token was not found."},
        "409": {"model": ApiError, "description": "A conflict error occured."},
        "500": {"model": ApiError, "description": "An unknown error occured."},
    },
    operation_id="UserController_recoverAccount",
)
def user_controller_recover_account(
    body: RecoveryFinishRequest, auth: AuthJWT = Depends(), session = Depends(get_session)
) -> SuccessfulLoginResponse:
    recovery = get_first_of(session, AccountRecovery, AccountRecovery.token == body.recoveryToken)
    if recovery is None:
        raise HTTP401Error("Recovery token was not found.")

    user = update_item(session, User, User.id == recovery.user_id, access_key = body.newAccessKey)
    delete_item(session, AccountRecovery, AccountRecovery.token == recovery.token)

    if body.deleteContent:
        FSHandler(user.id, session).delete_all()

    return login_handler(auth, user)


@app.post(
    "/user/delete",
    status_code=200,
    response_description="Account deletion successful.",
    tags=["/user/"],
    responses={
        "401": {"model": ApiError, "description": "Access Token is incorrect."},
        "409": {
            "model": ApiError,
            "description": "Cannot delete accounts with active recurring subscriptions.",
        },
        "500": {"model": ApiError, "description": "An unknown error occured."},
    },
    operation_id="UserController_deleteAccountUnchecked",
)
def user_controller_delete_account_unchecked(
    auth: AuthJWT = Depends(), session = Depends(get_session)
) -> None:
    user = get_user(auth, session)
    if user.active:
        raise HTTP409Error("Cannot delete accounts with active recurring subscriptions.")

    delete_item(session, User, User.id == user.user_id)


@app.get(
    "/user/data",
    response_model=UserAccountDataResponse,
    status_code=200,
    response_description="Various user information.",
    tags=["/user/"],
    responses={
        "401": {"model": ApiError, "description": "Access Token is incorrect."},
        "500": {"model": ApiError, "description": "An unknown error occured."},
    },
    operation_id="UserController_getUserData",
)
def user_controller_get_user_data(
    auth: AuthJWT = Depends(), session = Depends(get_session)
) -> UserAccountDataResponse:
    return UserHandler(auth, session).user_account_data


@app.get(
    "/user/priority",
    response_model=PriorityResponse,
    status_code=200,
    response_description="Amount of max priority actions left, next max priority action refill (UNIX timestamp) "
                         "and current task priority.",
    tags=["/user/"],
    responses={
        "401": {"model": ApiError, "description": "Access Token is incorrect."},
        "500": {"model": ApiError, "description": "An unknown error occured."},
    },
    operation_id="UserController_getCurrentPriority"
)
def user_controller_get_current_priority(
    auth: AuthJWT = Depends(), session = Depends(get_session)
) -> PriorityResponse:
    return UserHandler(auth, session).priority


@app.get(
    "/user/giftkeys",
    response_model=GiftKeysResponse,
    status_code=200,
    response_description="Purchased Gift Keys.",
    tags=["/user/"],
    responses={
        "401": {"model": ApiError, "description": "Access Token is incorrect."},
        "500": {"model": ApiError, "description": "An unknown error occured."},
    },
    operation_id="UserController_getGiftKeys",
)
def user_controller_get_gift_keys(
    auth: AuthJWT = Depends(), session = Depends(get_session)
) -> GiftKeysResponse:
    user_id = get_user_id(auth)

    giftkeys = get_multiple_of(session, GiftKey, GiftKey.user_id == user_id)

    return GiftKeysResponse(giftKeys = [giftkey.dict() for giftkey in giftkeys])


@app.get(
    "/user/keystore",
    response_model=GetKeystoreResponse,
    status_code=200,
    response_description="Keystore buffer in Base64 format.",
    tags=["/user/"],
    responses={
        "401": {"model": ApiError, "description": "Access Token is incorrect."},
        "500": {"model": ApiError, "description": "An unknown error occured."},
    },
    operation_id="UserController_getKeystore",
)
def user_controller_get_keystore(
    auth: AuthJWT = Depends(),
) -> GetKeystoreResponse:
    keystore = FSHandler(auth).read_internal_object("keystore")

    return GetKeystoreResponse(keystore = keystore)


@app.get(
    "/user/subscription",
    response_model=SubscriptionResponse,
    status_code=200,
    response_description="Current subscription, date of expiry and perks.",
    tags=["/user/"],
    responses={
        "401": {"model": ApiError, "description": "Access Token is incorrect."},
        "500": {"model": ApiError, "description": "An unknown error occured."},
    },
    operation_id="UserController_getSubscription",
)
def user_controller_get_subscription(
    auth: AuthJWT = Depends(), session = Depends(get_session)
) -> SubscriptionResponse:
    return UserHandler(auth, session).subscription


@app.put(
    "/user/keystore",
    status_code=200,
    response_description="Edit is successful.",
    tags=["/user/"],
    responses={
        "400": {"model": ApiError, "description": "A validation error occured."},
        "401": {"model": ApiError, "description": "Access Token is incorrect."},
        "500": {"model": ApiError, "description": "An unknown error occured."},
    },
    operation_id="UserController_updateKeystore",
)
def user_controller_update_keystore(
    body: UpdateKeystoreRequest, auth: AuthJWT = Depends()
) -> None:
    # TODO: should we use body.changeIndex ?
    FSHandler(auth).write_internal_object("keystore", body.keystore)


@app.get(
    "/user/objects/{obj_type}",
    response_model=ObjectsResponse,
    status_code=200,
    response_description="List of serverside-stored objects of that obj_type.",
    tags=["/user/"],
    responses={
        "401": {"model": ApiError, "description": "Access Token is incorrect."},
        "500": {"model": ApiError, "description": "An unknown error occured."},
    },
    operation_id="UserController_getObjects",
)
def user_controller_get_objects(
    obj_type: ObjectType, auth: AuthJWT = Depends(), session = Depends(get_session)
) -> ObjectsResponse:
    user_datas = FSHandler(auth, session).read_objects(obj_type)

    return ObjectsResponse(objects = [UserData(**user_data) for user_data in user_datas])


@app.put(
    "/user/objects/{obj_type}",
    response_model=UserData,
    status_code=200,
    response_description="Object created successfully.",
    tags=["/user/"],
    responses={
        "400": {"model": ApiError, "description": "A validation error occured."},
        "401": {"model": ApiError, "description": "Access Token is incorrect."},
        "404": {"model": ApiError, "description": "Specified object was not found."},
        "500": {"model": ApiError, "description": "An unknown error occured."},
    },
    operation_id="UserController_createObject",
)
def user_controller_create_object(
    obj_type: ObjectType, body: UserDataInput = ..., auth: AuthJWT = Depends(), session = Depends(get_session)
) -> UserData:
    user_data = FSHandler(auth, session).write_object(obj_type, body.meta, body.dict())

    return UserData(**user_data)


@app.get(
    "/user/objects/{obj_type}/{obj_id}",
    response_model=UserData,
    status_code=200,
    response_description="Found object.",
    tags=["/user/"],
    responses={
        "401": {"model": ApiError, "description": "Access Token is incorrect."},
        "500": {"model": ApiError, "description": "An unknown error occured."},
    },
    operation_id="UserController_getObject",
)
def user_controller_get_object(
    obj_type: ObjectType, obj_id: str = ..., auth: AuthJWT = Depends(), session = Depends(get_session)
) -> UserData:
    user_data = FSHandler(auth, session).read_object(obj_type, obj_id)

    return UserData(**user_data)


@app.patch(
    "/user/objects/{obj_type}/{obj_id}",
    response_model=UserData,
    status_code=200,
    response_description="Object edited successfully.",
    tags=["/user/"],
    responses={
        "400": {"model": ApiError, "description": "A validation error occured."},
        "401": {"model": ApiError, "description": "Access Token is incorrect."},
        "404": {"model": ApiError, "description": "Specified object was not found."},
        "409": {
            "model": ApiError,
            "description": "A conflict occured while updating this object.",
        },
        "500": {"model": ApiError, "description": "An unknown error occured."},
    },
    operation_id="UserController_editObject",
)
def user_controller_edit_object(
    obj_id: str,
    obj_type: ObjectType = ...,
    body: UserDataInput = ...,
    auth: AuthJWT = Depends(),
    session = Depends(get_session)
) -> UserData:
    user_data = FSHandler(auth, session).patch_object(obj_type, obj_id, body.dict())

    return UserData(**user_data)


@app.delete(
    "/user/objects/{obj_type}/{obj_id}",
    response_model=UserData,
    status_code=200,
    response_description="Object deleted successfully.",
    tags=["/user/"],
    responses={
        "401": {"model": ApiError, "description": "Access Token is incorrect."},
        "404": {"model": ApiError, "description": "Specified object was not found."},
        "500": {"model": ApiError, "description": "An unknown error occured."},
    },
    operation_id="UserController_deleteObject",
)
def user_controller_delete_object(
    obj_id: str, obj_type: ObjectType = ..., auth: AuthJWT = Depends(), session = Depends(get_session)
) -> UserData:
    user_data = FSHandler(auth, session).delete_object(obj_type, obj_id)

    return UserData(**user_data)


@app.put(
    "/user/clientsettings",
    status_code=200,
    response_description="Edit is successful.",
    tags=["/user/"],
    responses={
        "400": {"model": ApiError, "description": "A validation error occured."},
        "401": {"model": ApiError, "description": "Access Token is incorrect."},
        "500": {"model": ApiError, "description": "An unknown error occured."},
    },
    operation_id="UserController_updateClientSettings",
)
def user_controller_update_client_settings(
    body: str, auth: AuthJWT = Depends()
) -> str:
    return FSHandler(auth).write_internal_object("clientsettings", body)


@app.get(
    "/user/clientsettings",
    status_code=200,
    response_description="Client settings in an arbitrary format.",
    tags=["/user/"],
    responses={
        "401": {"model": ApiError, "description": "Access Token is incorrect."},
        "500": {"model": ApiError, "description": "An unknown error occured."},
    },
    operation_id="UserController_getClientSettings",
)
def user_controller_get_client_settings(
    auth: AuthJWT = Depends(),
) -> str:
    return FSHandler(auth).read_internal_object("clientsettings")


@app.post(
    "/user/submission",
    status_code=200,
    response_description="Submission is successful.",
    tags=["/user/"],
    responses={
        "400": {"model": ApiError, "description": "A validation error occured."},
        "401": {"model": ApiError, "description": "Access Token is incorrect."},
        "500": {"model": ApiError, "description": "An unknown error occured."},
    },
    operation_id="UserController_postUserSubmission",
)
def user_controller_post_user_submission(
    body: UserSubmissionInput, auth: AuthJWT = Depends(), session = Depends(get_session)
) -> None:
    user_id = get_user_id(auth)

    submission = UserSubmission(user_id = user_id, **body.dict())
    insert_item(session, submission)


@app.get(
    "/user/submission/{event}",
    status_code=200,
    response_description="User submission",
    tags=["/user/"],
    responses={
        "401": {"model": ApiError, "description": "Access Token is incorrect."},
        "500": {"model": ApiError, "description": "An unknown error occured."},
    },
    operation_id="UserController_getUserSubmission",
)
def user_controller_get_user_submission(
    event: str, auth: AuthJWT = Depends(), session = Depends(get_session)
) -> UserSubmissionInput:
    user_id = get_user_id(auth)

    submission = get_first_of(
        session,
        UserSubmission,
        UserSubmission.user_id == user_id and UserSubmission.event == event
    )
    if submission is None:
        raise HTTP404Error()

    return UserSubmissionInput(**submission.dict())


@app.get(
    "/user/vote-submission/{event}",
    status_code=200,
    response_description="User submission votes",
    tags=["/user/"],
    responses={
        "401": {"model": ApiError, "description": "Access Token is incorrect."},
        "500": {"model": ApiError, "description": "An unknown error occured."},
    },
    operation_id="UserController_getUserSubmissionVotes",
)
def user_controller_get_user_submission_votes(
    event: str, auth: AuthJWT = Depends(), session = Depends(get_session)
) -> int:
    user_id = get_user_id(auth)
    votes = count(session, UserSubmission.user_id == user_id and UserSubmissionVote.event == event)

    return votes


@app.post(
    "/user/vote-submission/{event}",
    status_code=200,
    response_description="Vote is successful.",
    tags=["/user/"],
    responses={
        "201": {"description": ""},
        "401": {"model": ApiError, "description": "Access Token is incorrect."},
        "409": {"model": ApiError, "description": "A conflict error occured."},
        "500": {"model": ApiError, "description": "An unknown error occured."},
    },
    operation_id="UserController_voteSubmission",
)
def user_controller_vote_submission(
    event: str, body: UserSubmissionVoteInput = ..., auth: AuthJWT = Depends(), session = Depends(get_session)
) -> None:
    user_id = get_user_id(auth)

    verify_exist_with(session, UserSubmission.id == body.id and UserSubmission.event == event)
    vote = UserSubmissionVote(user_id = user_id, event = event, submission_id = body.id)

    insert_item(session, vote)


@app.delete(
    "/user/vote-submission/{event}",
    status_code=200,
    response_description="Vote is successful.",
    tags=["/user/"],
    responses={
        "401": {"model": ApiError, "description": "Access Token is incorrect."},
        "409": {"model": ApiError, "description": "A conflict error occured."},
        "500": {"model": ApiError, "description": "An unknown error occured."},
    },
    operation_id="UserController_retractSubmissionVote",
)
def user_controller_retract_submission_vote(
    event: str, body: UserSubmissionVoteInput = ..., auth: AuthJWT = Depends(), session = Depends(get_session)
) -> None:
    auth.jwt_required()
    user_id = get_user_id(auth)
    delete_item(
        session,
        UserSubmissionVote,
        (
            UserSubmissionVote.user_id == user_id and
            UserSubmissionVote.submission_id == body.id and
            UserSubmissionVote.event == event
        )
    )


@app.post(
    "/user/subscription/bind",
    status_code=201,
    response_description="Subscription has been bound properly.",
    tags=["/user/subscription/"],
    responses={
        "400": {"model": ApiError, "description": "A validation error occured."},
        "401": {"model": ApiError, "description": "Access Token is incorrect."},
        "404": {"model": ApiError, "description": "Subscription ID was not found"},
        "409": {
            "model": ApiError,
            "description": "A conflict occured while binding subscription.",
        },
        "500": {"model": ApiError, "description": "An unknown error occured."},
    },
    operation_id="SubscriptionController_bindSubscription",
)
def subscription_controller_bind_subscription(
    body: BindSubscriptionRequest, auth: AuthJWT = Depends(), session = Depends(get_session)
) -> None:
    user_id = get_user_id(auth)

    update_item(session, User, User.id == user_id, paymentProcessorData = body.dict())


@app.post(
    "/user/subscription/change",
    status_code=200,
    response_description="Subscription plan has been changed properly.",
    tags=["/user/subscription/"],
    responses={
        "400": {"model": ApiError, "description": "A validation error occured."},
        "401": {"model": ApiError, "description": "Access Token is incorrect."},
        "404": {"model": ApiError, "description": "Subscription SKU was not found"},
        "409": {
            "model": ApiError,
            "description": "A conflict occured while changing subscription plan.",
        },
        "500": {"model": ApiError, "description": "An unknown error occured."},
    },
    operation_id="SubscriptionController_changeSubscriptionPlan",
)
def subscription_controller_change_subscription_plan(
    body: ChangeSubscriptionPlanRequest, auth: AuthJWT = Depends(), session = Depends(get_session)
) -> None:
    user_id = get_user_id(auth)

    # there, a payment processor request should be processed and paid
    update_item(session, User, User.id == user_id, tier = SubscriptionTier(body.newSubscriptionPlan.value))


@app.post(
    "/ai/generate",
    response_model=AiGenerateResponse,
    status_code=201,
    response_description="The output has been successfully generated.",
    tags=["/ai/"],
    responses={
        "400": {"model": ApiError, "description": "A validation error occured."},
        "401": {"model": ApiError, "description": "Access Token is incorrect."},
        "402": {
            "model": ApiError,
            "description": "An active subscription is required to access this endpoint.",
        },
        "409": {"model": ApiError, "description": "A conflict error occured."},
        "500": {"model": ApiError, "description": "An unknown error occured."},
    },
    operation_id="AIController_aiGenerate",
)
def ai_controller_ai_generate(
    body: AiGenerateRequest,
    auth: AuthJWT = Depends(),
) -> AiGenerateResponse:
    auth.jwt_required()

    length = body.parameters.max_length
    tokens = text_tokens[model_to_tokenizer[body.model]][:length * 2]

    return AiGenerateResponse(output = tokens)


@app.post(
    "/ai/generate-stream",
    response_model=AiGenerateStreamableResponse,
    status_code=201,
    response_description="The request has been accepted and the output is generating (SSE).",
    tags=["/ai/"],
    responses={
        "400": {"model": ApiError, "description": "A validation error occured."},
        "401": {"model": ApiError, "description": "Access Token is incorrect."},
        "402": {
            "model": ApiError,
            "description": "An active subscription is required to access this endpoint.",
        },
        "409": {"model": ApiError, "description": "A conflict error occured."},
        "500": {"model": ApiError, "description": "An unknown error occured."},
    },
    operation_id="AIController_aiGenerateStreamable",
)
def ai_controller_ai_generate_streamable(
    body: AiGenerateRequest, auth: AuthJWT = Depends()
) -> AiGenerateStreamableResponse:
    auth.jwt_required()

    length = int(body.parameters.max_length)
    tokens = text_tokens[model_to_tokenizer[body.model]][:length]

    for i in range(length):
        yield AiGenerateStreamableResponse(ptr = i, token = tokens[i * 2:(i + 1) * 2], final = (i == length - 1))


image_model_hash = {
    Model1.nai_diffusion: "81274D13",
    Model1.safe_diffusion: "",
    Model1.nai_diffusion_furry: ""
}


@app.post(
    "/ai/generate-image",
    response_model=AiGenerateImageResponse,
    status_code=201,
    response_description="The request has been accepted and the output is generating (SSE).",
    tags=["/ai/"],
    responses={
        "400": {"model": ApiError, "description": "A validation error occured."},
        "401": {"model": ApiError, "description": "Access Token is incorrect."},
        "402": {
            "model": ApiError,
            "description": "An active subscription is required to access this endpoint.",
        },
        "409": {"model": ApiError, "description": "A conflict error occured."},
        "500": {"model": ApiError, "description": "An unknown error occured."},
    },
    operation_id="AIController_aiGenerateImage",
)
def ai_controller_ai_generate_image(
    body: AiGenerateImageRequest,
    auth: AuthJWT = Depends(),
) -> AiGenerateImageResponse:
    auth.jwt_required()

    width = body.parameters["width"]
    height = body.parameters["height"]
    n_samples = body.parameters.get("n_samples", 1)
    seed: Optional[int] = body.parameters["seed"]

    metadata_to_keep = ["steps", "sampler", "seed", "strength", "noise", "scale", "uc", "qualityToggle", "ucPreset"]
    metadata = {k: v for k, v in body.parameters.items() if k in metadata_to_keep}

    png_data = PngInfo()
    png_data.add_text("Title", "AI generated image")
    png_data.add_text("Description", body.input)
    png_data.add_text("Software", "NovelAI")
    png_data.add_text("Source", f"Stable Diffusion {image_model_hash[body.model]}")

    for i in range(n_samples):
        img = Image.new("RGB", (width, height))
        img.paste((200, 200, 200), (0, 0, img.size[0], img.size[1]))
        # TODO: fill image

        png_data.add_text("Comment", metadata)

        image = io.BytesIO()
        img.save(image, "png", pnginfo = png_data)
        yield image

        metadata["seed"] += 1


@app.post(
    "/ai/classify",
    response_model=AiSequenceClassificationResponse,
    status_code=201,
    response_description="The output has been successfully generated.",
    tags=["/ai/"],
    responses={
        "400": {"model": ApiError, "description": "A validation error occured."},
        "401": {"model": ApiError, "description": "Access Token is incorrect."},
        "402": {
            "model": ApiError,
            "description": "An active subscription is required to access this endpoint.",
        },
        "409": {"model": ApiError, "description": "A conflict error occured."},
        "500": {"model": ApiError, "description": "An unknown error occured."},
    },
    operation_id="AIController_classify",
)
def ai_controller_classify(
    auth: AuthJWT = Depends(),
) -> AiSequenceClassificationResponse:
    auth.jwt_required()

    raise HTTP400Error("Incorrect body.")


@app.get(
    "/ai/generate-image/suggest-tags",
    response_model=AiRequestImageGenerationTagsResponse,
    status_code=200,
    tags=["/ai/"],
    responses={
        "401": {"model": ApiError, "description": "Access Token is incorrect."},
        "500": {"model": ApiError, "description": "An unknown error occured."},
    },
    operation_id="AIController_generateImageTags",
)
def ai_controller_generate_image_tags(
    _model: str, _prompt: str = ..., auth: AuthJWT = Depends()
) -> AiRequestImageGenerationTagsResponse:
    auth.jwt_required()

    return AiRequestImageGenerationTagsResponse(
        tags = [
            AiRequestImageGenerationTag(
                tag = ''.join(choices(ascii_lowercase, k = randrange(3, 8))),
                count = randrange(100, 100_000_000),
                confidence = random()
            ) for _ in range(randrange(1, 20))
        ]
    )


@app.get(
    "/ai/generate-voice",
    status_code=200,
    tags=["/ai/"],
    responses={
        "401": {"model": ApiError, "description": "Access Token is incorrect."},
        "500": {"model": ApiError, "description": "An unknown error occured."},
    },
    operation_id="AIController_generateVoice",
)
def ai_controller_generate_voice(
    text: str,
    seed: str = ...,
    voice: float = ...,
    opus: bool = ...,
    version: str = ...,
    auth: AuthJWT = Depends(),
) -> str:
    auth.jwt_required()

    # TODO


training_queue = TrainingQueue(get_session())


async def run_training_queue():
    loop = asyncio.get_running_loop()
    await loop.run_in_executor(None, training_queue.run)


@app.post(
    "/ai/module/train",
    response_model = AiModuleDto,
    status_code = 201,
    response_description = "The training request has been successfully sent.",
    tags = ["/ai/module/"],
    responses = {
        "400": { "model": ApiError, "description": "A validation error occured." },
        "401": { "model": ApiError, "description": "Access Token is incorrect." },
        "402": {
            "model"      : ApiError,
            "description": "An active subscription required to access this endpoint.",
        },
        "409": { "model": ApiError, "description": "A conflict error occured." },
        "500": { "model": ApiError, "description": "An unknown error occured." },
    },
    operation_id = "AIModuleController_trainModule",
)
def ai_module_controller_train_module(
    body: AiModuleTrainRequest, auth: AuthJWT = Depends()
) -> AiModuleDto:
    auth.jwt_required()

    module = AiModuleDto(
        **body.dict(),
        lastUpdatedAt = time.time(),
        status = Status.pending,
        lossHistory = [],
        id = str(uuid4()),
    )
    valid = training_queue.add_module(module)

    if not valid:
        module.status = Status.error
        raise JSON409Error(module.dict())

    return module


@app.get(
    "/ai/module/all",
    response_model = List[AiModuleDto],
    status_code = 200,
    tags = ["/ai/module/"],
    responses = {
        "401": { "model": ApiError, "description": "Access Token is incorrect." },
        "500": { "model": ApiError, "description": "An unknown error occured." },
    },
    operation_id = "AIModuleController_allModules",
)
def ai_module_controller_all_modules(
    auth: AuthJWT = Depends(), session = Depends(get_session)
) -> List[AiModuleDto]:
    user_id = get_user_id(auth)

    modules = get_multiple_of(session, AiModule, AiModule.user_id == user_id)

    return [AiModuleDto(**module.dict()) for module in modules]


@app.get(
    "/ai/module/{obj_id}",
    response_model = AiModuleDto,
    status_code = 200,
    tags = ["/ai/module/"],
    responses = {
        "401": { "model": ApiError, "description": "Access Token is incorrect." },
        "404": { "model": ApiError, "description": "Module not found" },
        "500": { "model": ApiError, "description": "An unknown error occured." },
    },
    operation_id = "AIModuleController_getModule",
)
def ai_module_controller_get_module(
    obj_id: str, auth: AuthJWT = Depends(), session = Depends(get_session)
) -> AiModuleDto:
    user_id = get_user_id(auth)

    module = get_first_of(session, AiModule, AiModule.user_id == user_id and AiModule.id == obj_id)
    if module is None:
        raise HTTP404Error("Module not found")

    return AiModuleDto(**module.dict())


@app.delete(
    "/ai/module/{obj_id}",
    response_model = AiModuleDto,
    status_code = 200,
    response_description = "Module deleted successfully.",
    tags = ["/ai/module/"],
    responses = {
        "401": { "model": ApiError, "description": "Access Token is incorrect." },
        "404": { "model": ApiError, "description": "Module not found" },
        "409": { "model": ApiError, "description": "A conflict error occured." },
        "500": { "model": ApiError, "description": "An unknown error occured." },
    },
    operation_id = "AIModuleController_deleteModule",
)
def ai_module_controller_delete_module(
    obj_id: str, auth: AuthJWT = Depends(), session = Depends(get_session)
) -> AiModuleDto:
    user_id = get_user_id(auth)

    module = delete_item(session, AiModule, AiModule.user_id == user_id and AiModule.id == obj_id)

    return AiModuleDto(**module.dict())


@app.post(
    "/ai/module/buy-training-steps",
    status_code = 200,
    response_description = "Steps have been purchased properly.",
    tags = ["/ai/module/"],
    responses = {
        "400": { "model": ApiError, "description": "A validation error occured." },
        "401": { "model": ApiError, "description": "Access Token is incorrect." },
        "409": {
            "model"      : ApiError,
            "description": "A conflict occured while buying training steps.",
        },
        "500": { "model": ApiError, "description": "An unknown error occured." },
    },
    operation_id = "AIModuleController_buyTrainingSteps",
)
def ai_module_controller_buy_training_steps(
    body: BuyTrainingStepsRequest, auth: AuthJWT = Depends(), session = Depends(get_session)
) -> None:
    user = get_user(auth, session)

    update_item(
        session,
        User,
        User.id == user.id,
        purchasedTrainingSteps = user.purchasedTrainingSteps + body.amount
    )


def start():
    uvicorn.run("mock.main:app", host="127.0.0.1", port=8000, reload=True)
